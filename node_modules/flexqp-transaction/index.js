var mysql = require('mysql');
var async = require('async');

function Processor() {
};


Processor.prototype.db = function (dbConfig) {
    dbConfig = dbConfig || {};
    var con = mysql.createConnection({
        host: dbConfig.host || this.host,
        user: dbConfig.user || this.user,
        password: dbConfig.password || this.password,
        database: dbConfig.database || this.database || 'flexpos3'
    });
    return con;
}

Processor.prototype.presetConnection = function (config) {
    this.host = config.host || this.host;
    this.user = config.user || this.user;
    this.password = config.password || this.password;
    this.database = config.database || this.database || 'flexpos3'

}

Processor.prototype.connect = function (_host, _user, _password) {
    console.log('connect() is Deprecated !! Use connectWithBegin');
    return new Promise((resolve, reject) => {
        var con = mysql.createConnection({
            host: _host || this.host,
            user: _user || this.user,
            password: _password || this.password
        });
        con.connect(function (err) {
            if (err) {
                err.status = 409;
                return reject(err);
            }
            return resolve(con);
        });
    });
}

Processor.prototype.connectWithTbeginConfig = function (config) {

    return new Promise((resolve, reject) => {
        var con = mysql.createConnection({
            host: config.host || this.host,
            user: config.user || this.user,
            password: config.password || this.password,
            database: config.database || this.database || 'flexpos3'
        });
        con.connect(function (err) {
            if (err) {
                err.status = 409;
                return reject(err);
            }
            con.beginTransaction(function (err) {
                if (err) {
                    err.status = 409;
                    return reject(err);
                }
                return resolve(con);
            });
        });
    });
}

Processor.prototype.connectWithTbegin = function (_host, _user, _password) {
    return new Promise((resolve, reject) => {
        var con = mysql.createConnection({
            host: _host || this.host,
            user: _user || this.user,
            password: _password || this.password
        });
        con.connect(function (err) {
            if (err) {
                err.status = 409;
                return reject(err);
            }
            con.beginTransaction(function (err) {
                if (err) {
                    err.status = 409;
                    return reject(err);
                }
                return resolve(con);
            });
        });
    });
}

Processor.prototype.executeLoop = function (times, query, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }
        async.times(times, function (n, callback) {
            con.query(query, params, function (err, result) {
                if (err) {
                    err._con = con;
                    err.status = 409;
                    return callback(err);
                } else {
                    result._con = con;
                    return callback(null, result);
                }
            })
        }, function (err, result) {
            if (err) {
                reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}

Processor.prototype.executeSmartLoop = function (query, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }
        if (params.length == 0) {
            var err = new Error('undefined parameter for smart loop');
            err._con = con;
            err.status = 409;
            return callback(err);
        }
        async.times(params.length, function (n, callback) {
            con.query(query, params[n], function (err, result) {
                if (err) {
                    err._con = con;
                    err.status = 409;
                    return callback(err);
                } else {
                    result._con = con;
                    return callback(null, result);
                }
            })
        }, function (err, result) {
            if (err) {
                reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}
Processor.prototype.executePairs = function (queryParamPair, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }
        if (queryParamPair.length == 0) {
            var err = new Error('undefined parameter for smart loop');
            err._con = con;
            err.status = 409;
            return callback(err);
        }

        async.times(queryParamPair.length, function (n, callback) {
            con.query(queryParamPair[n].query, queryParamPair[n].params, function (err, result) {
                if (err) {
                    err._con = con;
                    err.status = 409;
                    return callback(err);
                } else {
                    result._con = con;
                    return callback(null, result);
                }
            })
        }, function (err, result) {
            if (err) {
                reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}

Processor.prototype.execute = function (query, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }

        con.query(query, params, function (err, result) {
            if (err) {
                err._con = con;
                err.status = 409;
                return reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}

Processor.prototype.executeWithOptions = function (option, params, con) {
    return new Promise((resolve, reject) => {
        params = params || [];

        if (!con) {
            throw new Error('undefined connection');
        }

        con.query(option, params, function (err, result) {
            if (err) {
                err._con = con;
                err.status = 409;
                return reject(err);
            } else {
                result._con = con;
                resolve(result);
            }
        })
    });
}

Processor.prototype.rollback = function (next, con) {
    if (!con) {
        var err = new Error('undefined connection');
        return next(err);
    }
    con.rollback(function (err) {
        if (err) {
            return next(err)
        }
    });
}

Processor.prototype.commit = function (next, con) {
    console.log('commit() is Deprecated !! Use commitAndCloseConnection');

    if (!con) {
        var err = new Error('undefined connection');
        return next(err);
    }
    con.commit(function (err) {
        if (err) {
            this.rollback();
            return next(err);
        } else {
            //done
        }
    });
}

Processor.prototype.closeConnection = function (next, con) {
    console.log('closeConnection() is Deprecated !! Use commitAndCloseConnection');

    if (!con) {
        var err = new Error('undefined connection');
        return next(err);
    }
    con.destroy();
}
/**
 * Added in 0.3.0
 */
Processor.prototype.rollbackAndCloseConnection = function (con) {

    return new Promise((resolve, reject) => {
        con.rollback(function (err) {
            if (err) {
                err.status = 409;
                err._con = con;
                reject(err);
            } else {
                con.destroy();
                resolve(null);
            }
        });
    })
}

Processor.prototype.commitAndCloseConnection = function (con) {

    return new Promise((resolve, reject) => {
        con.commit(function (err) {
            if (err) {
                err.status = 409;
                err._con = con;
                reject(err);
            } else {
                con.destroy();
                resolve(null);
            }
        });
    })
}

/**
 * Added by Roger 2017-09-28
 */
Processor.prototype.connectAndExecute = function (config, query, params) {
    return new Promise((resolve, reject) => {
        params = params || [];

        var con = mysql.createConnection({
            host: config.host || this.host,
            user: config.user || this.user,
            password: config.password || this.password
        });
        con.connect(function (err) {
            if (err) {
                err.status = 409;
                return reject(err);
            }
            resolve(con);
        });
    }).then(result => {
        return new Promise((resolve, reject) => {
            result.query(query, params, function (err, result) {
                if (err) {
                    err._con = result;
                    err.status = 409;
                    return reject(err);
                } else {
                    result._con = result;
                    return resolve(result);
                }
            });
        })
    });
};

Processor.prototype.ignoreAndForward = function (con) {
    return new Promise((resolve, reject) => {
        resolve(con);
    })
}

/**
 * This is from flexqp1
 */


Processor.prototype.getHost = function () {
    return this.host;
}
Processor.prototype.connect = function (dbConfig) {
    return this.db(dbConfig);
}

Processor.prototype.executeUpdateIgnore = function (query, params, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            console.log('there is a db connection err');
            console.log("Nothing affected");
            return;
        }
        con.query(query, params, function (err, result) {
            if (err) {
                err.status = 409;
                console.log(err.message);
                con.destroy();
                return;
            }
            if (result.affectedRows == 0) {
                console.log("Nothing affected");
                con.destroy();
                return;
            }
            params.id = result.insertId;
            con.destroy();
        });
    });
}

Processor.prototype.executeUpdate = function (query, params, callback, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            err.status = 409;
            callback(err);
            return;
        }
        con.query(query, params, function (err, result) {
            if (err) {
                console.log(err.message);
                //next(err);
                con.destroy();
                try {
                    callback(err, params);
                } catch (err) {
                    err.status = 409;
                    callback(err);
                }
                return;
            }
            if (result.affectedRows == 0) {
                var err = new Error("Nothing Updated");
                err.status = 406;
                console.log("Nothing affected");
                //next(err);
                con.destroy();
                try {
                    callback(err, result);
                } catch (err) {
                    err.status = 409;
                    callback(err);
                }
                return;
            }
            //res.json(params);
            con.destroy();
            try {
                callback(err, result);
            } catch (err) {
                err.status = 409;
                callback(err);
            }
        });
    });
}
Processor.prototype.executeUpdatePromise = function (query, params, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                err.status = 409;
                reject(err);
                return;
            }
            con.query(query, params, function (err, result) {
                if (err) {
                    con.destroy();
                    err.status = 409;
                    reject(err);
                    return;
                }
                con.destroy();
                resolve(result);
            });
        });
    });
}
Processor.prototype.executeUpdateIgnorePromise = function (query, params, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                // err.status = 409;
                // reject(err);
                return resolve(err);
            }
            con.query(query, params, function (err, result) {
                if (err) {
                    console.log(err.message);
                    con.destroy();
                    // err.status = 409;
                    // reject(err);
                    return resolve(err);
                }
                con.destroy();
                return resolve(result);
            });
        });
    });
}
Processor.prototype.executeUpdateEnd = function (res, next, query, params, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            next(err);
            return;
        }
        con.query(query, params, function (err, result) {
            if (err) {
                err.status = 409;
                console.log(err.message);
                next(err);
                con.destroy();
                return;
            }
            if (result.affectedRows == 0) {
                var err = new Error("Nothing Updated");
                err.status = 406;
                console.log("Nothing affected");
                next(err);
                con.destroy();
                return;
            }
            params.id = result.insertId;

            res.json(params);
            con.destroy();
        });
    });
}
Processor.prototype.executeAndFetch = function (query, params, callback, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            callback(err);
            return;
        } var options = {
            sql: query, typeCast: function (field, next) {
                if (field.type == 'JSON') {
                    return JSON.parse(field.string());
                }
                return next();
            }
        };
        con.query(options, params, function (err, result) {
            if (err) {
                con.destroy();
                err.status = 409;
                return callback(err);
            }
            try {
                callback(null, result);
            } catch (err) {
                callback(err);
            }
            con.destroy();

        });
    });
}

Processor.prototype.executeAndFetchPromise = function (query, params, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];
        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                reject(err);
                return;
            } var options = {
                sql: query, typeCast: function (field, next) {
                    if (field.type == 'JSON') {
                        return JSON.parse(field.string());
                    }
                    return next();
                }
            };
            con.query(options, params, function (err, result) {
                if (err) {
                    con.destroy();
                    err.status = 409;
                    return reject(err);
                }
                con.destroy();
                resolve(result);
            });
        });
    })
}
Processor.prototype.executeAndFetchWithOptions = function (query, params, options, callback, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            callback(err);
            return;
        }
        // var options = {
        //     sql: query, typeCast: function (field, next) {
        //         if (field.type == 'JSON') {
        //             return JSON.parse(field.string());
        //         }
        //         return next();
        //     }
        // };
        con.query(options, params, function (err, result) {
            if (err) {
                con.destroy();
                err.status = 409;
                return callback(err);
            }
            try {
                callback(null, result);
            } catch (err) {
                callback(err);
            }
            con.destroy();

        });
    });
}
Processor.prototype.executeAndFetchWithOptionsPromise = function (query, params, options, dbConfig) {

    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                reject(err);
                return;
            }
            // var options = {
            //     sql: query, typeCast: function (field, next) {
            //         if (field.type == 'JSON') {
            //             return JSON.parse(field.string());
            //         }
            //         return next();
            //     }
            // };
            con.query(options, params, function (err, result) {
                if (err) {
                    con.destroy();
                    err.status = 409;
                    return reject(err);
                }
                con.destroy();
                resolve(result);
            });
        });
    })
}
Processor.prototype.executeAndFetchFirst = function (query, params, callback, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            callback(err);
            return;
        }
        var options = {
            sql: query, typeCast: function (field, next) {
                if (field.type == 'JSON') {
                    return JSON.parse(field.string());
                }
                return next();
            }
        };
        con.query(options, params, function (err, result) {
            con.destroy();
            if (err) {
                err.status = 409;
                return callback(err);
            }
            try {
                callback(err, result[0]);
            } catch (err) {
                callback(err);
            }
        });
    });
}
Processor.prototype.executeAndFetchFirstPromise = function (query, params, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                reject(err);
                return;
            }
            var options = {
                sql: query, typeCast: function (field, next) {
                    if (field.type == 'JSON') {
                        return JSON.parse(field.string());
                    }
                    return next();
                }
            };
            con.query(options, params, function (err, result) {
                con.destroy();
                if (err) {
                    err.status = 409;
                    return reject(err);
                }
                if (result)
                    resolve(result[0]);
                else
                    resolve({});
            });
        });
    })
}

Processor.prototype.executeAndFetchFirstWithOptions = function (query, params, options, callback, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            callback(err);
            return;
        }
        // var options = {
        //     sql: query, typeCast: function (field, next) {
        //         if (field.type == 'JSON') {
        //             return JSON.parse(field.string());
        //         }
        //         return next();
        //     }
        // };
        con.query(options, params, function (err, result) {
            if (err) {
                con.destroy();
                err.status = 409;
                return callback(err);
            }
            try {
                callback(err, result[0]);
            } catch (err) {
                err.status = 409;
                callback(err);
            }
            con.destroy();
        });
    });
}

Processor.prototype.executeAndFetchFirstWithOptionsPromise = function (query, params, options, dbConfig) {
    return new Promise((resolve, reject) => {
        params = params || [];

        //perform db work
        var con = this.db(dbConfig);
        con.connect(function (err) {
            if (err) {
                reject(err);
                return;
            }
            // var options = {
            //     sql: query, typeCast: function (field, next) {
            //         if (field.type == 'JSON') {
            //             return JSON.parse(field.string());
            //         }
            //         return next();
            //     }
            // };
            con.query(options, params, function (err, result) {
                if (err) {
                    con.destroy();
                    err.status = 409;
                    return reject(err);
                }
                con.destroy();
                resolve(result);
            });
        });
    })
}
Processor.prototype.executeAndFetchEnd = function (res, next, query, params, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            next(err);
            return;
        }
        con.query(query, params, function (err, result) {
            if (err) {
                console.log(err.message);
                err.status = 409;
                next(err);
                con.destroy();
                return;
            }
            res.json(result);
            con.destroy();
        });
    });
}
Processor.prototype.executeAndFetchFirstEnd = function (res, next, query, params, dbConfig) {
    //perform db work
    var con = this.db(dbConfig);
    con.connect(function (err) {
        if (err) {
            err.status = 409;
            next(err);
            return;
        }
        con.query(query, params, function (err, result) {
            if (err) {
                console.log(err.message);
                err.status = 409;
                next(err);
                con.destroy();
                return;
            }
            if (result) {
                delete result[0].password;
                delete result[0].availability;
                res.json(result[0]);
                con.destroy();
            } else {
                var err = new Error('Not Found');
                err.status = 406;
                next(err);
                con.destroy();
                return;
            }
            con.destroy();
        });
    });
}


module.exports = new Processor();
